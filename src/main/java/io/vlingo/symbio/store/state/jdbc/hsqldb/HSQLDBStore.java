// Copyright Â© 2012-2018 Vaughn Vernon. All rights reserved.
//
// This Source Code Form is subject to the terms of the
// Mozilla Public License, v. 2.0. If a copy of the MPL
// was not distributed with this file, You can obtain
// one at https://mozilla.org/MPL/2.0/.

package io.vlingo.symbio.store.state.jdbc.hsqldb;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.MessageFormat;

import io.vlingo.actors.Logger;
import io.vlingo.symbio.store.state.StateStore.DataFormat;
import io.vlingo.symbio.store.state.StateTypeStateStoreMap;

class HSQLDBStore {
  final static String SQL_DISPATCHABLE_APPEND =
          "INSERT INTO TBL_VLINGO_SYMBIO_DISPATCHABLES \n" +
               "(D_ID, D_ORIGINATOR_ID, D_DISPATCH_ID, \n" +
               " D_STATE_ID, D_STATE_TYPE, D_STATE_TYPE_VERSION, \n" +
               " D_STATE_DATA, D_STATE_DATA_VERSION, \n" +
               " D_STATE_METADATA_VALUE, D_STATE_METADATA_OP, D_STATE_METADATA_OBJECT, D_STATE_METADATA_OBJECT_TYPE) \n" +
               "VALUES (DEFAULT, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  final static String SQL_DISPATCHABLE_DELETE =
          "DELETE FROM TBL_VLINGO_SYMBIO_DISPATCHABLES WHERE D_DISPATCH_ID = ?";

  final static String SQL_DISPATCHABLE_SELECT =
          "SELECT D_DISPATCH_ID, D_STATE_ID, D_STATE_TYPE, D_STATE_TYPE_VERSION, D_STATE_DATA, D_STATE_DATA_VERSION, \n" +
          "       D_STATE_METADATA_VALUE, D_STATE_METADATA_OP, D_STATE_METADATA_OBJECT, D_STATE_METADATA_OBJECT_TYPE \n" +
          "FROM TBL_VLINGO_SYMBIO_DISPATCHABLES \n" +
          "WHERE D_ORIGINATOR_ID = ? ORDER BY D_ID";

  final static String SQL_STATE_READ =
          "SELECT TBL_{0}.S_TYPE, TBL_{0}.S_TYPE_VERSION, TBL_{0}.S_DATA, TBL_{0}.S_DATA_VERSION, TBL_{0}.S_METADATA_VALUE, TBL_{0}.S_METADATA_OP " +
          "FROM TBL_{0} " +
          "WHERE TBL_{0}.S_ID = ?";

  final static String SQL_STATE_WRITE =
          "MERGE INTO TBL_{0} \n" +
          "USING (VALUES ?, ?, ?, {1}, ?, ?, ?) \n" +
          "S (S_ID, S_TYPE, S_TYPE_VERSION, S_DATA, S_DATA_VERSION, S_METADATA_OP, S_METADATA_VALUE) \n" +
          "ON (TBL_{0}.S_ID = S.S_ID) \n" +
          "WHEN MATCHED THEN UPDATE \n" +
                  "SET TBL_{0}.S_TYPE = S.S_TYPE, \n" +
                  "    TBL_{0}.S_TYPE_VERSION = S.S_TYPE_VERSION, \n" +
                  "    TBL_{0}.S_DATA = S.S_DATA, \n" +
                  "    TBL_{0}.S_DATA_VERSION = S.S_DATA_VERSION, \n" +
                  "    TBL_{0}.S_METADATA_OP = S.S_METADATA_OP, \n" +
                  "    TBL_{0}.S_METADATA_VALUE = S.S_METADATA_VALUE \n" +
          "WHEN NOT MATCHED THEN INSERT \n" +
                  "(S_ID, S_TYPE, S_TYPE_VERSION, S_DATA, S_DATA_VERSION, S_METADATA_OP, S_METADATA_VALUE) \n" +
                  "VALUES (S.S_ID, S.S_TYPE, S.S_TYPE_VERSION, S.S_DATA, S.S_DATA_VERSION, S.S_METADATA_VALUE, S.S_METADATA_OP)";

  final static String SQL_FORMAT_BINARY_CAST = "CAST(? AS VARBINARY(65535))";
  final static String SQL_FORMAT_TEXT_CAST = "CAST(? AS LONGVARCHAR(65535))";

  private final static String TBL_VLINGO_SYMBIO_DISPATCHABLES = "TBL_VLINGO_SYMBIO_DISPATCHABLES";
  private final static String SQL_CREATE_DISPATCHABLES_STORE =
          "CREATE TABLE TBL_VLINGO_SYMBIO_DISPATCHABLES (\n" +
          "   D_ID BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY," +
          "   D_ORIGINATOR_ID VARCHAR(32) NOT NULL," +
          "   D_DISPATCH_ID VARCHAR(128) NOT NULL,\n" +
          "   D_STATE_ID VARCHAR(128) NOT NULL, \n" +
          "   D_STATE_TYPE VARCHAR(256) NOT NULL,\n" +
          "   D_STATE_TYPE_VERSION INT NOT NULL,\n" +
          "   D_STATE_DATA {0} NOT NULL,\n" +
          "   D_STATE_DATA_VERSION INT NOT NULL,\n" +
          "   D_STATE_METADATA_VALUE VARCHAR(4000) NOT NULL,\n" +
          "   D_STATE_METADATA_OP VARCHAR(128) NOT NULL,\n" +
          "   D_STATE_METADATA_OBJECT LONGVARCHAR(65535),\n" +
          "   D_STATE_METADATA_OBJECT_TYPE VARCHAR(256)\n" +
          ");";

  private final static String SQL_DISPATCH_ID_INDEX =
          "CREATE INDEX IDX_DISPATCHABLES_DISPATCH_ID \n" + 
          "ON TBL_VLINGO_SYMBIO_DISPATCHABLES (D_DISPATCH_ID);";

  private final static String SQL_ORIGINATOR_ID_INDEX =
          "CREATE INDEX IDX_DISPATCHABLES_ORIGINATOR_ID \n" + 
          "ON TBL_VLINGO_SYMBIO_DISPATCHABLES (D_ORIGINATOR_ID);";

  private final static String SQL_CREATE_STATE_STORE =
          "CREATE TABLE TBL_{0} (\n" +
          "   S_ID VARCHAR(128) NOT NULL,\n" +
          "   S_TYPE VARCHAR(256) NOT NULL,\n" +
          "   S_TYPE_VERSION INT NOT NULL,\n" +
          "   S_DATA {1} NOT NULL,\n" +
          "   S_DATA_VERSION INT NOT NULL,\n" +
          "   S_METADATA_VALUE VARCHAR(4000) NOT NULL,\n" +
          "   S_METADATA_OP VARCHAR(128) NOT NULL,\n" +
          "   PRIMARY KEY (S_ID) \n" +
          ");";

  private final static String SQL_FORMAT_TEXT = "LONGVARCHAR(65535)";
  private final static String SQL_FORMAT_BINARY = "VARBINARY(65535)";

  protected void createDispatchablesTable(final Connection connection, final DataFormat format) throws Exception {
    if (!tableExists(connection, TBL_VLINGO_SYMBIO_DISPATCHABLES)) {
      Statement statement = null;
      try {
        final String createDispatchablesStore = MessageFormat.format(SQL_CREATE_DISPATCHABLES_STORE,
                format.isBinary() ? SQL_FORMAT_BINARY : SQL_FORMAT_TEXT);
        statement = connection.createStatement();
        statement.executeUpdate(createDispatchablesStore);
        statement.executeUpdate(SQL_DISPATCH_ID_INDEX);
        statement.executeUpdate(SQL_ORIGINATOR_ID_INDEX);
        connection.commit();
      } finally {
        if (statement != null) {
          statement.close();
        }
      }
    }
  }

  protected void createTables(final Connection connection, final DataFormat format, final Logger logger) {
    try {
      createDispatchablesTable(connection, format);
    } catch (Exception e) {
      // assume table exists; could look at metadata
      logger.log("Could not create dispatchables table because: " + e.getMessage(), e);
    }

    for (final String storeName : StateTypeStateStoreMap.allStoreNames()) {
      final String postfixTableName = storeName.toUpperCase();
      try {
        if (!tableExists(connection, tableNameFor(postfixTableName))) {
          createStateStoreTable(connection, postfixTableName, format);
        }
      } catch (Exception e) {
        // assume table exists; could look at metadata
        logger.log("Could not create " + postfixTableName + " table because: " + e.getMessage(), e);
      }
    }
  }

  protected void createStateStoreTable(final Connection connection, final String tableName, final DataFormat format) throws Exception {
    final String sql = MessageFormat.format(SQL_CREATE_STATE_STORE, tableName,
            format.isBinary() ? SQL_FORMAT_BINARY : SQL_FORMAT_TEXT);
    Statement statement = null;
    try {
      statement = connection.createStatement();
      statement.executeUpdate(sql);
      connection.commit();
    } finally {
      if (statement != null) {
        statement.close();
      }
    }
  }

  protected void dropAllInternalResouces(final Connection connection) throws Exception {
    dropTable(connection, TBL_VLINGO_SYMBIO_DISPATCHABLES);
  }

  protected void dropTable(final Connection connection, String tableName) throws Exception {
    try (Statement statement = connection.createStatement()) {
      statement.executeUpdate("DROP TABLE " + tableName);
    }
  }

  protected boolean tableExists(final Connection connection, String tableName) throws Exception {
    DatabaseMetaData metadata = connection.getMetaData();
    try (final ResultSet resultSet = metadata.getTables(null, null, tableName, null)) {
      return resultSet.next();
    }
  }

  protected String tableNameFor(final String storeName) {
    return "TBL_" + storeName;
  }
}
